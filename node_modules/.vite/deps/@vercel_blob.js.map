{
  "version": 3,
  "sources": ["../../retry/lib/retry_operation.js", "../../retry/lib/retry.js", "../../retry/index.js", "../../async-retry/lib/index.js", "../../bytes/index.js", "../../is-buffer/index.js", "../../@vercel/blob/dist/undici-browser.js", "../../@vercel/blob/src/helpers.ts", "../../@vercel/blob/src/api.ts", "../../@vercel/blob/src/debug.ts", "../../@vercel/blob/src/put-helpers.ts", "../../@vercel/blob/src/multipart/complete.ts", "../../@vercel/blob/src/multipart/create.ts", "../../@vercel/blob/src/multipart/upload.ts", "../../@vercel/blob/src/put.ts", "../../@vercel/blob/src/multipart/helpers.ts", "../../@vercel/blob/src/multipart/uncontrolled.ts", "../../@vercel/blob/src/multipart/create-uploader.ts", "../../is-plain-object/dist/is-plain-object.mjs", "../../@vercel/blob/dist/stream-browser.js", "../../@vercel/blob/src/del.ts", "../../@vercel/blob/src/head.ts", "../../@vercel/blob/src/list.ts", "../../@vercel/blob/src/copy.ts", "../../@vercel/blob/src/index.ts"],
  "sourcesContent": ["function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n", "var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n", "module.exports = require('./lib/retry');", "// Packages\nvar retrier = require('retry');\n\nfunction retry(fn, opts) {\n  function run(resolve, reject) {\n    var options = opts || {};\n    var op;\n\n    // Default `randomize` to true\n    if (!('randomize' in options)) {\n      options.randomize = true;\n    }\n\n    op = retrier.operation(options);\n\n    // We allow the user to abort retrying\n    // this makes sense in the cases where\n    // knowledge is obtained that retrying\n    // would be futile (e.g.: auth errors)\n\n    function bail(err) {\n      reject(err || new Error('Aborted'));\n    }\n\n    function onError(err, num) {\n      if (err.bail) {\n        bail(err);\n        return;\n      }\n\n      if (!op.retry(err)) {\n        reject(op.mainError());\n      } else if (options.onRetry) {\n        options.onRetry(err, num);\n      }\n    }\n\n    function runAttempt(num) {\n      var val;\n\n      try {\n        val = fn(bail, num);\n      } catch (err) {\n        onError(err, num);\n        return;\n      }\n\n      Promise.resolve(val)\n        .then(resolve)\n        .catch(function catchIt(err) {\n          onError(err, num);\n        });\n    }\n\n    op.attempt(runAttempt);\n  }\n\n  return new Promise(run);\n}\n\nmodule.exports = retry;\n", "/*!\n * bytes\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015 Jed Watson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = bytes;\nmodule.exports.format = format;\nmodule.exports.parse = parse;\n\n/**\n * Module variables.\n * @private\n */\n\nvar formatThousandsRegExp = /\\B(?=(\\d{3})+(?!\\d))/g;\n\nvar formatDecimalsRegExp = /(?:\\.0*|(\\.[^0]+)0+)$/;\n\nvar map = {\n  b:  1,\n  kb: 1 << 10,\n  mb: 1 << 20,\n  gb: 1 << 30,\n  tb: Math.pow(1024, 4),\n  pb: Math.pow(1024, 5),\n};\n\nvar parseRegExp = /^((-|\\+)?(\\d+(?:\\.\\d+)?)) *(kb|mb|gb|tb|pb)$/i;\n\n/**\n * Convert the given value in bytes into a string or parse to string to an integer in bytes.\n *\n * @param {string|number} value\n * @param {{\n *  case: [string],\n *  decimalPlaces: [number]\n *  fixedDecimals: [boolean]\n *  thousandsSeparator: [string]\n *  unitSeparator: [string]\n *  }} [options] bytes options.\n *\n * @returns {string|number|null}\n */\n\nfunction bytes(value, options) {\n  if (typeof value === 'string') {\n    return parse(value);\n  }\n\n  if (typeof value === 'number') {\n    return format(value, options);\n  }\n\n  return null;\n}\n\n/**\n * Format the given value in bytes into a string.\n *\n * If the value is negative, it is kept as such. If it is a float,\n * it is rounded.\n *\n * @param {number} value\n * @param {object} [options]\n * @param {number} [options.decimalPlaces=2]\n * @param {number} [options.fixedDecimals=false]\n * @param {string} [options.thousandsSeparator=]\n * @param {string} [options.unit=]\n * @param {string} [options.unitSeparator=]\n *\n * @returns {string|null}\n * @public\n */\n\nfunction format(value, options) {\n  if (!Number.isFinite(value)) {\n    return null;\n  }\n\n  var mag = Math.abs(value);\n  var thousandsSeparator = (options && options.thousandsSeparator) || '';\n  var unitSeparator = (options && options.unitSeparator) || '';\n  var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;\n  var fixedDecimals = Boolean(options && options.fixedDecimals);\n  var unit = (options && options.unit) || '';\n\n  if (!unit || !map[unit.toLowerCase()]) {\n    if (mag >= map.pb) {\n      unit = 'PB';\n    } else if (mag >= map.tb) {\n      unit = 'TB';\n    } else if (mag >= map.gb) {\n      unit = 'GB';\n    } else if (mag >= map.mb) {\n      unit = 'MB';\n    } else if (mag >= map.kb) {\n      unit = 'KB';\n    } else {\n      unit = 'B';\n    }\n  }\n\n  var val = value / map[unit.toLowerCase()];\n  var str = val.toFixed(decimalPlaces);\n\n  if (!fixedDecimals) {\n    str = str.replace(formatDecimalsRegExp, '$1');\n  }\n\n  if (thousandsSeparator) {\n    str = str.split('.').map(function (s, i) {\n      return i === 0\n        ? s.replace(formatThousandsRegExp, thousandsSeparator)\n        : s\n    }).join('.');\n  }\n\n  return str + unitSeparator + unit;\n}\n\n/**\n * Parse the string value into an integer in bytes.\n *\n * If no unit is given, it is assumed the value is in bytes.\n *\n * @param {number|string} val\n *\n * @returns {number|null}\n * @public\n */\n\nfunction parse(val) {\n  if (typeof val === 'number' && !isNaN(val)) {\n    return val;\n  }\n\n  if (typeof val !== 'string') {\n    return null;\n  }\n\n  // Test if the string passed is valid\n  var results = parseRegExp.exec(val);\n  var floatValue;\n  var unit = 'b';\n\n  if (!results) {\n    // Nothing could be extracted from the given string\n    floatValue = parseInt(val, 10);\n    unit = 'b'\n  } else {\n    // Retrieve the value and the unit\n    floatValue = parseFloat(results[1]);\n    unit = results[4].toLowerCase();\n  }\n\n  if (isNaN(floatValue)) {\n    return null;\n  }\n\n  return Math.floor(map[unit] * floatValue);\n}\n", "/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n", "// this file gets copied to the dist folder\n// it makes undici work in the browser by reusing the global fetch\n// it's the simplest way I've found to make http requests work in Node.js, Serverles Functions, Edge Functions, and the browser\n// this should work as long as this module is used via Next.js/Webpack\n// moving forward we will have to solve this problem in a more robust way\n// reusing https://github.com/inrupt/universal-fetch\n// or seeing how/if cross-fetch solves https://github.com/lquixada/cross-fetch/issues/69\nexport const fetch = globalThis.fetch.bind(globalThis);\n", "// common util interface for blob raw commands, not meant to be used directly\n// this is why it's not exported from index/client\n\nexport interface BlobCommandOptions {\n  /**\n   * Define your blob API token.\n   * @defaultvalue process.env.BLOB_READ_WRITE_TOKEN\n   */\n  token?: string;\n  /**\n   * `AbortSignal` to cancel the running request. See https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\n   */\n  abortSignal?: AbortSignal;\n}\n\n// shared interface for put, copy and multipartUpload\nexport interface CommonCreateBlobOptions extends BlobCommandOptions {\n  /**\n   * Whether the blob should be publicly accessible. Support for private blobs is planned.\n   */\n  access: 'public';\n  /**\n   * Adds a random suffix to the filename.\n   * @defaultvalue true\n   */\n  addRandomSuffix?: boolean;\n  /**\n   * Defines the content type of the blob. By default, this value is inferred from the pathname. Sent as the 'content-type' header when downloading a blob.\n   */\n  contentType?: string;\n  /**\n   * Number in seconds to configure the edge and browser cache. The maximum values are 5 minutes for the edge cache and unlimited for the browser cache.\n   * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob#caching\n   * @defaultvalue 365 * 24 * 60 * 60 (1 Year)\n   */\n  cacheControlMaxAge?: number;\n}\n\nexport function getTokenFromOptionsOrEnv(options?: BlobCommandOptions): string {\n  if (options?.token) {\n    return options.token;\n  }\n\n  if (process.env.BLOB_READ_WRITE_TOKEN) {\n    return process.env.BLOB_READ_WRITE_TOKEN;\n  }\n\n  throw new BlobError(\n    'No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls.',\n  );\n}\n\nexport class BlobError extends Error {\n  constructor(message: string) {\n    super(`Vercel Blob: ${message}`);\n  }\n}\n\nexport function getDownloadUrl(blobUrl: string): string {\n  const url = new URL(blobUrl);\n\n  url.searchParams.set('download', '1');\n\n  return url.toString();\n}\n", "import type { RequestInit, Response } from 'undici';\nimport { fetch } from 'undici';\nimport retry from 'async-retry';\nimport { debug } from './debug';\nimport type { BlobCommandOptions } from './helpers';\nimport { BlobError, getTokenFromOptionsOrEnv } from './helpers';\n\nexport class BlobAccessError extends BlobError {\n  constructor() {\n    super('Access denied, please provide a valid token for this resource.');\n  }\n}\n\nexport class BlobStoreNotFoundError extends BlobError {\n  constructor() {\n    super('This store does not exist.');\n  }\n}\n\nexport class BlobStoreSuspendedError extends BlobError {\n  constructor() {\n    super('This store has been suspended.');\n  }\n}\n\nexport class BlobUnknownError extends BlobError {\n  constructor() {\n    super('Unknown error, please visit https://vercel.com/help.');\n  }\n}\n\nexport class BlobNotFoundError extends BlobError {\n  constructor() {\n    super('The requested blob does not exist');\n  }\n}\n\nexport class BlobServiceNotAvailable extends BlobError {\n  constructor() {\n    super('The blob service is currently not available. Please try again.');\n  }\n}\n\nexport class BlobServiceRateLimited extends BlobError {\n  public readonly retryAfter: number;\n\n  constructor(seconds?: number) {\n    super(\n      `Too many requests please lower the number of concurrent requests ${\n        seconds ? ` - try again in ${seconds} seconds` : ''\n      }.`,\n    );\n\n    this.retryAfter = seconds ?? 0;\n  }\n}\n\nexport class BlobRequestAbortedError extends BlobError {\n  constructor() {\n    super('The request was aborted.');\n  }\n}\n\ntype BlobApiErrorCodes =\n  | 'store_suspended'\n  | 'forbidden'\n  | 'not_found'\n  | 'unknown_error'\n  | 'bad_request'\n  | 'store_not_found'\n  | 'not_allowed'\n  | 'service_unavailable'\n  | 'rate_limited';\n\nexport interface BlobApiError {\n  error?: { code?: BlobApiErrorCodes; message?: string };\n}\n\n// This version is used to ensure that the client and server are compatible\n// The server (Vercel Blob API) uses this information to change its behavior like the\n// response format\nconst BLOB_API_VERSION = 7;\n\nfunction getApiVersion(): string {\n  let versionOverride = null;\n  try {\n    // wrapping this code in a try/catch as this function is used in the browser and Vite doesn't define the process.env.\n    // As this varaible is NOT used in production, it will always default to the BLOB_API_VERSION\n    versionOverride =\n      process.env.VERCEL_BLOB_API_VERSION_OVERRIDE ||\n      process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;\n  } catch {\n    // noop\n  }\n\n  return `${versionOverride ?? BLOB_API_VERSION}`;\n}\n\nfunction getApiUrl(pathname = ''): string {\n  let baseUrl = null;\n  try {\n    // wrapping this code in a try/catch as this function is used in the browser and Vite doesn't define the process.env.\n    // As this varaible is NOT used in production, it will always default to production endpoint\n    baseUrl =\n      process.env.VERCEL_BLOB_API_URL ||\n      process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;\n  } catch {\n    // noop\n  }\n  return `${baseUrl || 'https://blob.vercel-storage.com'}${pathname}`;\n}\n\nfunction getRetries(): number {\n  try {\n    const retries = process.env.VERCEL_BLOB_RETRIES || '10';\n\n    return parseInt(retries, 10);\n  } catch {\n    return 10;\n  }\n}\n\nfunction createBlobServiceRateLimited(\n  response: Response,\n): BlobServiceRateLimited {\n  const retryAfter = response.headers.get('retry-after');\n\n  return new BlobServiceRateLimited(\n    retryAfter ? parseInt(retryAfter, 10) : undefined,\n  );\n}\n\n// reads the body of a error response\nasync function getBlobError(\n  response: Response,\n): Promise<{ code: string; error: BlobError }> {\n  let code: BlobApiErrorCodes;\n  let message: string | undefined;\n\n  try {\n    const data = (await response.json()) as BlobApiError;\n\n    code = data.error?.code ?? 'unknown_error';\n    message = data.error?.message;\n  } catch {\n    code = 'unknown_error';\n  }\n\n  let error: BlobError;\n  switch (code) {\n    case 'store_suspended':\n      error = new BlobStoreSuspendedError();\n      break;\n    case 'forbidden':\n      error = new BlobAccessError();\n      break;\n    case 'not_found':\n      error = new BlobNotFoundError();\n      break;\n    case 'store_not_found':\n      error = new BlobStoreNotFoundError();\n      break;\n    case 'bad_request':\n      error = new BlobError(message ?? 'Bad request');\n      break;\n    case 'service_unavailable':\n      error = new BlobServiceNotAvailable();\n      break;\n    case 'rate_limited':\n      error = createBlobServiceRateLimited(response);\n      break;\n    case 'unknown_error':\n    case 'not_allowed':\n    default:\n      error = new BlobUnknownError();\n      break;\n  }\n\n  return { code, error };\n}\n\nexport async function requestApi<TResponse>(\n  pathname: string,\n  init: RequestInit,\n  commandOptions: BlobCommandOptions | undefined,\n): Promise<TResponse> {\n  const apiVersion = getApiVersion();\n  const token = getTokenFromOptionsOrEnv(commandOptions);\n  const extraHeaders = getProxyThroughAlternativeApiHeaderFromEnv();\n\n  const [, , , storeId = ''] = token.split('_');\n  const requestId = `${storeId}:${Date.now()}:${Math.random().toString(16).slice(2)}`;\n  let retryCount = 0;\n\n  const apiResponse = await retry(\n    async (bail) => {\n      let res: Response;\n\n      // try/catch here to treat certain errors as not-retryable\n      try {\n        res = await fetch(getApiUrl(pathname), {\n          ...init,\n          headers: {\n            'x-api-blob-request-id': requestId,\n            'x-api-blob-request-attempt': String(retryCount),\n            'x-api-version': apiVersion,\n            authorization: `Bearer ${token}`,\n            ...extraHeaders,\n            ...init.headers,\n          },\n        });\n      } catch (error) {\n        // if the request was aborted, don't retry\n        if (error instanceof DOMException && error.name === 'AbortError') {\n          bail(new BlobRequestAbortedError());\n          return;\n        }\n\n        // retry for any other erros thrown by fetch\n        throw error;\n      }\n\n      if (res.ok) {\n        return res;\n      }\n\n      const { code, error } = await getBlobError(res);\n\n      // only retry for certain errors\n      if (\n        code === 'unknown_error' ||\n        code === 'service_unavailable' ||\n        code === 'internal_server_error'\n      ) {\n        throw error;\n      }\n\n      // don't retry for e.g. suspended stores\n      bail(error);\n    },\n    {\n      retries: getRetries(),\n      onRetry: (error) => {\n        debug(`retrying API request to ${pathname}`, error.message);\n        retryCount = retryCount + 1;\n      },\n    },\n  );\n\n  if (!apiResponse) {\n    throw new BlobUnknownError();\n  }\n\n  return (await apiResponse.json()) as TResponse;\n}\n\nfunction getProxyThroughAlternativeApiHeaderFromEnv(): {\n  'x-proxy-through-alternative-api'?: string;\n} {\n  const extraHeaders: Record<string, string> = {};\n\n  try {\n    if ('VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API' in process.env) {\n      extraHeaders['x-proxy-through-alternative-api'] =\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- we know it's here from the if\n        process.env.VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API!;\n    } else if (\n      'NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API' in process.env\n    ) {\n      extraHeaders['x-proxy-through-alternative-api'] =\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- we know it's here from the if\n        process.env.NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API!;\n    }\n  } catch {\n    // noop\n  }\n\n  return extraHeaders;\n}\n", "let debugIsActive = false;\n\n// wrapping this code in a try/catch in case some env doesn't support process.env (vite by default)\ntry {\n  if (\n    process.env.DEBUG?.includes('blob') ||\n    process.env.NEXT_PUBLIC_DEBUG?.includes('blob')\n  ) {\n    debugIsActive = true;\n  }\n} catch (error) {\n  // noop\n}\n\n// Set process.env.DEBUG = 'blob' to enable debug logging\nexport function debug(message: string, ...args: unknown[]): void {\n  if (debugIsActive) {\n    // eslint-disable-next-line no-console -- Ok for debugging\n    console.debug(`vercel-blob: ${message}`, ...args);\n  }\n}\n", "// eslint-disable-next-line unicorn/prefer-node-protocol -- node:stream does not resolve correctly in browser and edge\nimport type { Readable } from 'stream';\nimport type { ClientCommonCreateBlobOptions } from './client';\nimport type { CommonCreateBlobOptions } from './helpers';\nimport { BlobError } from './helpers';\n\nconst putOptionHeaderMap = {\n  cacheControlMaxAge: 'x-cache-control-max-age',\n  addRandomSuffix: 'x-add-random-suffix',\n  contentType: 'x-content-type',\n};\n\nexport interface PutBlobResult {\n  url: string;\n  downloadUrl: string;\n  pathname: string;\n  contentType?: string;\n  contentDisposition: string;\n}\n\nexport type PutBlobApiResponse = PutBlobResult;\n\nexport type PutBody =\n  | string\n  | Readable // Node.js streams\n  | Buffer // Node.js buffers\n  | Blob\n  | ArrayBuffer\n  | ReadableStream // Streams API (= Web streams in Node.js)\n  | File;\n\nexport type CommonPutCommandOptions = CommonCreateBlobOptions &\n  ClientCommonCreateBlobOptions;\n\nexport interface CreatePutMethodOptions<TOptions> {\n  allowedOptions: (keyof typeof putOptionHeaderMap)[];\n  getToken?: (pathname: string, options: TOptions) => Promise<string>;\n  extraChecks?: (options: TOptions) => void;\n}\n\nexport function createPutHeaders<TOptions extends CommonPutCommandOptions>(\n  allowedOptions: CreatePutMethodOptions<TOptions>['allowedOptions'],\n  options: TOptions,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n\n  if (allowedOptions.includes('contentType') && options.contentType) {\n    headers[putOptionHeaderMap.contentType] = options.contentType;\n  }\n\n  if (\n    allowedOptions.includes('addRandomSuffix') &&\n    options.addRandomSuffix !== undefined\n  ) {\n    headers[putOptionHeaderMap.addRandomSuffix] = options.addRandomSuffix\n      ? '1'\n      : '0';\n  }\n\n  if (\n    allowedOptions.includes('cacheControlMaxAge') &&\n    options.cacheControlMaxAge !== undefined\n  ) {\n    headers[putOptionHeaderMap.cacheControlMaxAge] =\n      options.cacheControlMaxAge.toString();\n  }\n\n  return headers;\n}\n\nexport async function createPutOptions<\n  TOptions extends CommonPutCommandOptions,\n>({\n  pathname,\n  options,\n  extraChecks,\n  getToken,\n}: {\n  pathname: string;\n  options?: TOptions;\n  extraChecks?: CreatePutMethodOptions<TOptions>['extraChecks'];\n  getToken?: CreatePutMethodOptions<TOptions>['getToken'];\n}): Promise<TOptions> {\n  if (!pathname) {\n    throw new BlobError('pathname is required');\n  }\n\n  if (!options) {\n    throw new BlobError('missing options, see usage');\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n  if (options.access !== 'public') {\n    throw new BlobError('access must be \"public\"');\n  }\n\n  if (extraChecks) {\n    extraChecks(options);\n  }\n\n  if (getToken) {\n    options.token = await getToken(pathname, options);\n  }\n\n  return options;\n}\n", "import { BlobServiceNotAvailable, requestApi } from '../api';\nimport { debug } from '../debug';\nimport type { CommonCreateBlobOptions, BlobCommandOptions } from '../helpers';\nimport type {\n  CreatePutMethodOptions,\n  PutBlobApiResponse,\n  PutBlobResult,\n} from '../put-helpers';\nimport { createPutHeaders, createPutOptions } from '../put-helpers';\nimport type { Part } from './helpers';\n\n// shared interface for server and client\nexport interface CommonCompleteMultipartUploadOptions {\n  uploadId: string;\n  key: string;\n}\n\nexport type CompleteMultipartUploadCommandOptions =\n  CommonCompleteMultipartUploadOptions & CommonCreateBlobOptions;\n\nexport function createCompleteMultipartUploadMethod<\n  TOptions extends CompleteMultipartUploadCommandOptions,\n>({ allowedOptions, getToken, extraChecks }: CreatePutMethodOptions<TOptions>) {\n  return async (pathname: string, parts: Part[], optionsInput: TOptions) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken,\n    });\n\n    const headers = createPutHeaders(allowedOptions, options);\n\n    return completeMultipartUpload({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      headers,\n      options,\n      parts,\n    });\n  };\n}\n\nexport async function completeMultipartUpload({\n  uploadId,\n  key,\n  pathname,\n  parts,\n  headers,\n  options,\n}: {\n  uploadId: string;\n  key: string;\n  pathname: string;\n  parts: Part[];\n  headers: Record<string, string>;\n  options: BlobCommandOptions;\n}): Promise<PutBlobResult> {\n  try {\n    const response = await requestApi<PutBlobApiResponse>(\n      `/mpu/${pathname}`,\n      {\n        method: 'POST',\n        headers: {\n          ...headers,\n          'content-type': 'application/json',\n          'x-mpu-action': 'complete',\n          'x-mpu-upload-id': uploadId,\n          // key can be any utf8 character so we need to encode it as HTTP headers can only be us-ascii\n          // https://www.rfc-editor.org/rfc/rfc7230#swection-3.2.4\n          'x-mpu-key': encodeURI(key),\n        },\n        body: JSON.stringify(parts),\n        signal: options.abortSignal,\n      },\n      options,\n    );\n\n    debug('mpu: complete', response);\n\n    return response;\n  } catch (error: unknown) {\n    if (\n      error instanceof TypeError &&\n      (error.message === 'Failed to fetch' || error.message === 'fetch failed')\n    ) {\n      throw new BlobServiceNotAvailable();\n    } else {\n      throw error;\n    }\n  }\n}\n", "import { BlobServiceNotAvailable, requestApi } from '../api';\nimport { debug } from '../debug';\nimport type { BlobCommandOptions, CommonCreateBlobOptions } from '../helpers';\nimport type { CreatePutMethodOptions } from '../put-helpers';\nimport { createPutHeaders, createPutOptions } from '../put-helpers';\n\nexport function createCreateMultipartUploadMethod<\n  TOptions extends CommonCreateBlobOptions,\n>({ allowedOptions, getToken, extraChecks }: CreatePutMethodOptions<TOptions>) {\n  return async (pathname: string, optionsInput: TOptions) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken,\n    });\n\n    const headers = createPutHeaders(allowedOptions, options);\n\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options,\n    );\n\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId,\n    };\n  };\n}\n\ninterface CreateMultipartUploadApiResponse {\n  uploadId: string;\n  key: string;\n}\n\nexport async function createMultipartUpload(\n  pathname: string,\n  headers: Record<string, string>,\n  options: BlobCommandOptions,\n): Promise<CreateMultipartUploadApiResponse> {\n  debug('mpu: create', 'pathname:', pathname);\n\n  try {\n    const response = await requestApi<CreateMultipartUploadApiResponse>(\n      `/mpu/${pathname}`,\n      {\n        method: 'POST',\n        headers: {\n          ...headers,\n          'x-mpu-action': 'create',\n        },\n        signal: options.abortSignal,\n      },\n      options,\n    );\n\n    debug('mpu: create', response);\n\n    return response;\n  } catch (error: unknown) {\n    if (\n      error instanceof TypeError &&\n      (error.message === 'Failed to fetch' || error.message === 'fetch failed')\n    ) {\n      throw new BlobServiceNotAvailable();\n    } else {\n      throw error;\n    }\n  }\n}\n", "import bytes from 'bytes';\nimport type { BodyInit } from 'undici';\nimport { isPlainObject } from 'is-plain-object';\nimport { BlobServiceNotAvailable, requestApi } from '../api';\nimport { debug } from '../debug';\nimport {\n  type CommonCreateBlobOptions,\n  type BlobCommandOptions,\n  BlobError,\n} from '../helpers';\nimport { createPutHeaders, createPutOptions } from '../put-helpers';\nimport type { PutBody, CreatePutMethodOptions } from '../put-helpers';\nimport type { Part, PartInput } from './helpers';\n\n// shared interface for server and client\nexport interface CommonMultipartUploadOptions {\n  uploadId: string;\n  key: string;\n  partNumber: number;\n}\n\nexport type UploadPartCommandOptions = CommonMultipartUploadOptions &\n  CommonCreateBlobOptions;\n\nexport function createUploadPartMethod<\n  TOptions extends UploadPartCommandOptions,\n>({ allowedOptions, getToken, extraChecks }: CreatePutMethodOptions<TOptions>) {\n  return async (\n    pathname: string,\n    body: PutBody,\n    optionsInput: TOptions,\n  ): Promise<Part> => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken,\n    });\n\n    const headers = createPutHeaders(allowedOptions, options);\n\n    if (isPlainObject(body)) {\n      throw new BlobError(\n        \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\",\n      );\n    }\n\n    const result = await uploadPart({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      part: { blob: body, partNumber: options.partNumber },\n      headers,\n      options,\n    });\n\n    return {\n      etag: result.etag,\n      partNumber: options.partNumber,\n    };\n  };\n}\n\nexport async function uploadPart({\n  uploadId,\n  key,\n  pathname,\n  headers,\n  options,\n  internalAbortController = new AbortController(),\n  part,\n}: {\n  uploadId: string;\n  key: string;\n  pathname: string;\n  headers: Record<string, string>;\n  options: BlobCommandOptions;\n  internalAbortController?: AbortController;\n  part: PartInput;\n}): Promise<UploadPartApiResponse> {\n  const responsePromise = requestApi<UploadPartApiResponse>(\n    `/mpu/${pathname}`,\n    {\n      signal: internalAbortController.signal,\n      method: 'POST',\n      headers: {\n        ...headers,\n        'x-mpu-action': 'upload',\n        'x-mpu-key': encodeURI(key),\n        'x-mpu-upload-id': uploadId,\n        'x-mpu-part-number': part.partNumber.toString(),\n      },\n      // weird things between undici types and native fetch types\n      body: part.blob as BodyInit,\n      // required in order to stream some body types to Cloudflare\n      // currently only supported in Node.js, we may have to feature detect this\n      // note: this doesn't send a content-length to the server\n      duplex: 'half',\n    },\n    options,\n  );\n\n  function handleAbort(): void {\n    internalAbortController.abort();\n  }\n\n  if (options.abortSignal?.aborted) {\n    // abort if the signal is already aborted\n    handleAbort();\n  } else {\n    // we connect the internal abort controller to the external abortSignal to allow the user to cancel the upload\n    options.abortSignal?.addEventListener('abort', handleAbort);\n  }\n\n  const response = await responsePromise;\n\n  options.abortSignal?.removeEventListener('abort', handleAbort);\n\n  return response;\n}\n\n// Most browsers will cap requests at 6 concurrent uploads per domain (Vercel Blob API domain)\n// In other environments, we can afford to be more aggressive\nconst maxConcurrentUploads = typeof window !== 'undefined' ? 6 : 8;\n\n// 5MB is the minimum part size accepted by Vercel Blob, but we set our default part size to 8mb like the aws cli\nconst partSizeInBytes = 8 * 1024 * 1024;\n\nconst maxBytesInMemory = maxConcurrentUploads * partSizeInBytes * 2;\n\ninterface UploadPartApiResponse {\n  etag: string;\n}\n\nexport interface BlobUploadPart {\n  partNumber: number;\n  blob: Blob;\n}\n\n// Can we rewrite this function without new Promise?\nexport function uploadAllParts({\n  uploadId,\n  key,\n  pathname,\n  stream,\n  headers,\n  options,\n}: {\n  uploadId: string;\n  key: string;\n  pathname: string;\n  stream: ReadableStream<ArrayBuffer>;\n  headers: Record<string, string>;\n  options: BlobCommandOptions;\n}): Promise<Part[]> {\n  debug('mpu: upload init', 'key:', key);\n  const internalAbortController = new AbortController();\n\n  return new Promise((resolve, reject) => {\n    const partsToUpload: BlobUploadPart[] = [];\n    const completedParts: Part[] = [];\n    const reader = stream.getReader();\n    let activeUploads = 0;\n    let reading = false;\n    let currentPartNumber = 1;\n    // this next variable is used to escape the read loop when an error occurs\n    let rejected = false;\n    let currentBytesInMemory = 0;\n    let doneReading = false;\n    let bytesSent = 0;\n\n    // This must be outside the read loop, in case we reach the maxBytesInMemory and\n    // we exit the loop but some bytes are still to be sent on the next read invocation.\n    let arrayBuffers: ArrayBuffer[] = [];\n    let currentPartBytesRead = 0;\n\n    read().catch(cancel);\n\n    async function read(): Promise<void> {\n      debug(\n        'mpu: upload read start',\n        'activeUploads:',\n        activeUploads,\n        'currentBytesInMemory:',\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        'bytesSent:',\n        bytes(bytesSent),\n      );\n\n      reading = true;\n\n      while (currentBytesInMemory < maxBytesInMemory && !rejected) {\n        try {\n          // eslint-disable-next-line no-await-in-loop -- A for loop is fine here.\n          const { value, done } = await reader.read();\n\n          if (done) {\n            doneReading = true;\n            debug('mpu: upload read consumed the whole stream');\n            // done is sent when the stream is fully consumed. That's why we're not using the value here.\n            if (arrayBuffers.length > 0) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: 'application/octet-stream',\n                }),\n              });\n\n              sendParts();\n            }\n            reading = false;\n            return;\n          }\n\n          currentBytesInMemory += value.byteLength;\n\n          // This code ensures that each part will be exactly of `partSizeInBytes` size\n          // Otherwise R2 will refuse it. AWS S3 is fine with parts of different sizes.\n          let valueOffset = 0;\n          while (valueOffset < value.byteLength) {\n            const remainingPartSize = partSizeInBytes - currentPartBytesRead;\n            const endOffset = Math.min(\n              valueOffset + remainingPartSize,\n              value.byteLength,\n            );\n\n            const chunk = value.slice(valueOffset, endOffset);\n\n            arrayBuffers.push(chunk);\n            currentPartBytesRead += chunk.byteLength;\n            valueOffset = endOffset;\n\n            if (currentPartBytesRead === partSizeInBytes) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: 'application/octet-stream',\n                }),\n              });\n\n              arrayBuffers = [];\n              currentPartBytesRead = 0;\n              sendParts();\n            }\n          }\n        } catch (error) {\n          cancel(error);\n        }\n      }\n\n      debug(\n        'mpu: upload read end',\n        'activeUploads:',\n        activeUploads,\n        'currentBytesInMemory:',\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        'bytesSent:',\n        bytes(bytesSent),\n      );\n\n      reading = false;\n    }\n\n    async function sendPart(part: BlobUploadPart): Promise<void> {\n      activeUploads++;\n\n      debug(\n        'mpu: upload send part start',\n        'partNumber:',\n        part.partNumber,\n        'size:',\n        part.blob.size,\n        'activeUploads:',\n        activeUploads,\n        'currentBytesInMemory:',\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        'bytesSent:',\n        bytes(bytesSent),\n      );\n\n      try {\n        const completedPart = await uploadPart({\n          uploadId,\n          key,\n          pathname,\n          headers,\n          options,\n          internalAbortController,\n          part,\n        });\n\n        debug(\n          'mpu: upload send part end',\n          'partNumber:',\n          part.partNumber,\n          'activeUploads',\n          activeUploads,\n          'currentBytesInMemory:',\n          `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n          'bytesSent:',\n          bytes(bytesSent),\n        );\n\n        if (rejected) {\n          return;\n        }\n\n        completedParts.push({\n          partNumber: part.partNumber,\n          etag: completedPart.etag,\n        });\n\n        currentBytesInMemory -= part.blob.size;\n        activeUploads--;\n        bytesSent += part.blob.size;\n\n        if (partsToUpload.length > 0) {\n          sendParts();\n        }\n\n        if (doneReading) {\n          if (activeUploads === 0) {\n            reader.releaseLock();\n            resolve(completedParts);\n          }\n          return;\n        }\n\n        if (!reading) {\n          read().catch(cancel);\n        }\n      } catch (error) {\n        // cancel if fetch throws an error\n        cancel(error);\n      }\n    }\n\n    function sendParts(): void {\n      if (rejected) {\n        return;\n      }\n\n      debug(\n        'send parts',\n        'activeUploads',\n        activeUploads,\n        'partsToUpload',\n        partsToUpload.length,\n      );\n\n      while (activeUploads < maxConcurrentUploads && partsToUpload.length > 0) {\n        const partToSend = partsToUpload.shift();\n        if (partToSend) {\n          void sendPart(partToSend);\n        }\n      }\n    }\n\n    function cancel(error: unknown): void {\n      // a previous call already rejected the whole call, ignore\n      if (rejected) {\n        return;\n      }\n      rejected = true;\n      internalAbortController.abort();\n      reader.releaseLock();\n      if (\n        error instanceof TypeError &&\n        (error.message === 'Failed to fetch' ||\n          error.message === 'fetch failed')\n      ) {\n        reject(new BlobServiceNotAvailable());\n      } else {\n        reject(error as Error);\n      }\n    }\n  });\n}\n", "import type { BodyInit } from 'undici';\nimport { isPlainObject } from 'is-plain-object';\nimport { requestApi } from './api';\nimport type { CommonCreateBlobOptions } from './helpers';\nimport { BlobError } from './helpers';\nimport { uncontrolledMultipartUpload } from './multipart/uncontrolled';\nimport type {\n  CreatePutMethodOptions,\n  PutBody,\n  PutBlobApiResponse,\n  PutBlobResult,\n} from './put-helpers';\nimport { createPutOptions, createPutHeaders } from './put-helpers';\n\nexport interface PutCommandOptions extends CommonCreateBlobOptions {\n  /**\n   * Whether to use multipart upload. Use this when uploading large files. It will split the file into multiple parts, upload them in parallel and retry failed parts.\n   * @defaultvalue false\n   */\n  multipart?: boolean;\n}\n\nexport function createPutMethod<TOptions extends PutCommandOptions>({\n  allowedOptions,\n  getToken,\n  extraChecks,\n}: CreatePutMethodOptions<TOptions>) {\n  return async function put<TPath extends string>(\n    pathname: TPath,\n    bodyOrOptions: TPath extends `${string}/` ? TOptions : PutBody,\n    optionsInput?: TPath extends `${string}/` ? never : TOptions,\n  ): Promise<PutBlobResult> {\n    const isFolderCreation = pathname.endsWith('/');\n\n    // prevent empty bodies for files\n    if (!bodyOrOptions && !isFolderCreation) {\n      throw new BlobError('body is required');\n    }\n\n    // runtime check for non TS users that provide all three args\n    if (bodyOrOptions && optionsInput && isFolderCreation) {\n      throw new BlobError('body is not allowed for creating empty folders');\n    }\n\n    // avoid using the options as body\n    const body = isFolderCreation ? undefined : bodyOrOptions;\n\n    if (body !== undefined && isPlainObject(body)) {\n      throw new BlobError(\n        \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\",\n      );\n    }\n\n    const options = await createPutOptions({\n      pathname,\n      // when no body is required (for folder creations) options are the second argument\n      options: isFolderCreation ? (bodyOrOptions as TOptions) : optionsInput,\n      extraChecks,\n      getToken,\n    });\n\n    const headers = createPutHeaders(allowedOptions, options);\n\n    if (options.multipart === true && body) {\n      return uncontrolledMultipartUpload(pathname, body, headers, options);\n    }\n\n    const response = await requestApi<PutBlobApiResponse>(\n      `/${pathname}`,\n      {\n        method: 'PUT',\n        body: body as BodyInit,\n        headers,\n        // required in order to stream some body types to Cloudflare\n        // currently only supported in Node.js, we may have to feature detect this\n        // note: this doesn't send a content-length to the server\n        duplex: 'half',\n        signal: options.abortSignal,\n      },\n      options,\n    );\n\n    return {\n      url: response.url,\n      downloadUrl: response.downloadUrl,\n      pathname: response.pathname,\n      contentType: response.contentType,\n      contentDisposition: response.contentDisposition,\n    };\n  };\n}\n", "// eslint-disable-next-line unicorn/prefer-node-protocol -- node:stream does not resolve correctly in browser and edge\nimport { Readable } from 'stream';\n// eslint-disable-next-line unicorn/prefer-node-protocol -- node:buffer does not resolve correctly in browser and edge\nimport type { Buffer } from 'buffer';\nimport isBuffer from 'is-buffer';\nimport type { PutBody } from '../put-helpers';\n\nexport interface PartInput {\n  partNumber: number;\n  blob: PutBody;\n}\n\nexport interface Part {\n  partNumber: number;\n  etag: string;\n}\n\nexport function toReadableStream(value: PutBody): ReadableStream<ArrayBuffer> {\n  // Already a ReadableStream, nothing to do\n  if (value instanceof ReadableStream) {\n    return value as ReadableStream<ArrayBuffer>;\n  }\n\n  // In the case of a Blob or File (which inherits from Blob), we could use .slice() to create pointers\n  // to the original data instead of loading data in memory gradually.\n  // Here's an explanation on this subject: https://stackoverflow.com/a/24834417\n  if (value instanceof Blob) {\n    return value.stream();\n  }\n\n  if (isNodeJsReadableStream(value)) {\n    return Readable.toWeb(value) as ReadableStream<ArrayBuffer>;\n  }\n\n  let streamValue: Uint8Array | ArrayBuffer;\n\n  if (value instanceof ArrayBuffer) {\n    streamValue = value;\n  } else if (isNodeJsBufferOrString(value)) {\n    streamValue = value.buffer;\n  } else {\n    streamValue = stringToUint8Array(value);\n  }\n\n  // from https://github.com/sindresorhus/to-readable-stream/blob/main/index.js\n  return new ReadableStream<ArrayBuffer>({\n    start(controller) {\n      controller.enqueue(streamValue);\n      controller.close();\n    },\n  });\n}\n\n// From https://github.com/sindresorhus/is-stream/\nfunction isNodeJsReadableStream(value: PutBody): value is Readable {\n  return (\n    typeof value === 'object' &&\n    typeof (value as Readable).pipe === 'function' &&\n    (value as Readable).readable &&\n    typeof (value as Readable)._read === 'function' &&\n    // @ts-expect-error _readableState does exists on Readable\n    typeof value._readableState === 'object'\n  );\n}\n\nfunction stringToUint8Array(s: string): Uint8Array {\n  const enc = new TextEncoder();\n  return enc.encode(s);\n}\n\nfunction isNodeJsBufferOrString(input: Buffer | string): input is Buffer {\n  return isBuffer(input);\n}\n", "import { debug } from '../debug';\nimport type { BlobCommandOptions } from '../helpers';\nimport type { PutBody, PutBlobResult } from '../put-helpers';\nimport { completeMultipartUpload } from './complete';\nimport { createMultipartUpload } from './create';\nimport { toReadableStream } from './helpers';\nimport { uploadAllParts } from './upload';\n\n// this automatically slices the body into parts and uploads all of them as multiple parts\nexport async function uncontrolledMultipartUpload(\n  pathname: string,\n  body: PutBody,\n  headers: Record<string, string>,\n  options: BlobCommandOptions,\n): Promise<PutBlobResult> {\n  debug('mpu: init', 'pathname:', pathname, 'headers:', headers);\n\n  const stream = toReadableStream(body);\n\n  // Step 1: Start multipart upload\n  const createMultipartUploadResponse = await createMultipartUpload(\n    pathname,\n    headers,\n    options,\n  );\n\n  // Step 2: Upload parts one by one\n  const parts = await uploadAllParts({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    stream,\n    headers,\n    options,\n  });\n\n  // Step 3: Complete multipart upload\n  const blob = await completeMultipartUpload({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    parts,\n    headers,\n    options,\n  });\n\n  return blob;\n}\n", "import { isPlainObject } from 'is-plain-object';\nimport { BlobError, type CommonCreateBlobOptions } from '../helpers';\nimport type { CreatePutMethodOptions, PutBody } from '../put-helpers';\nimport { createPutHeaders, createPutOptions } from '../put-helpers';\nimport { completeMultipartUpload } from './complete';\nimport { createMultipartUpload } from './create';\nimport type { Part } from './helpers';\nimport { uploadPart as rawUploadPart } from './upload';\n\nexport function createCreateMultipartUploaderMethod<\n  TOptions extends CommonCreateBlobOptions,\n>({ allowedOptions, getToken, extraChecks }: CreatePutMethodOptions<TOptions>) {\n  return async (pathname: string, optionsInput: TOptions) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken,\n    });\n\n    const headers = createPutHeaders(allowedOptions, options);\n\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options,\n    );\n\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId,\n\n      async uploadPart(partNumber: number, body: PutBody) {\n        if (isPlainObject(body)) {\n          throw new BlobError(\n            \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\",\n          );\n        }\n\n        const result = await rawUploadPart({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          part: { partNumber, blob: body },\n          headers,\n          options,\n        });\n\n        return {\n          etag: result.etag,\n          partNumber,\n        };\n      },\n\n      async complete(parts: Part[]) {\n        return completeMultipartUpload({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          parts,\n          headers,\n          options,\n        });\n      },\n    };\n  };\n}\n", "/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (ctor === undefined) return true;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\n\nexport { isPlainObject };\n", "// This file is here because Edge Functions have no support for Node.js streams by default\n// It's unlikely someone would try to read/use a Node.js stream in an Edge function but we still put\n// a message in case this happens\n\nexport const Readable = {\n  toWeb() {\n    throw new Error(\n      'Vercel Blob: Sorry, we cannot get a Readable stream in this environment. If you see this message please open an issue here: https://github.com/vercel/storage/ with details on your environment.',\n    );\n  },\n};\n", "import { requestApi } from './api';\nimport type { BlobCommandOptions } from './helpers';\n\n/**\n * Deletes one or multiple blobs from your store.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#delete-a-blob\n *\n * @param url - Blob url or array of blob urls that identify the blobs to be deleted. You can only delete blobs that are located in a store, that your 'BLOB_READ_WRITE_TOKEN' has access to.\n * @param options - Additional options for the request.\n */\nexport async function del(\n  url: string[] | string,\n  options?: BlobCommandOptions,\n): Promise<void> {\n  await requestApi(\n    '/delete',\n    {\n      method: 'POST',\n      headers: { 'content-type': 'application/json' },\n      body: JSON.stringify({ urls: Array.isArray(url) ? url : [url] }),\n      signal: options?.abortSignal,\n    },\n    options,\n  );\n}\n", "import { requestApi } from './api';\nimport type { BlobCommandOptions } from './helpers';\n\nexport interface HeadBlobResult {\n  url: string;\n  downloadUrl: string;\n  size: number;\n  uploadedAt: Date;\n  pathname: string;\n  contentType: string;\n  contentDisposition: string;\n  cacheControl: string;\n}\n\ninterface HeadBlobApiResponse extends Omit<HeadBlobResult, 'uploadedAt'> {\n  uploadedAt: string; // when receiving data from our API, uploadedAt is a string\n}\n\n/**\n * Fetches metadata of a blob object.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#get-blob-metadata\n *\n * @param url - Blob url to lookup.\n * @param options - Additional options for the request.\n */\nexport async function head(\n  url: string,\n  options?: BlobCommandOptions,\n): Promise<HeadBlobResult> {\n  const searchParams = new URLSearchParams({ url });\n\n  const response = await requestApi<HeadBlobApiResponse>(\n    `?${searchParams.toString()}`,\n    // HEAD can't have body as a response, so we use GET\n    {\n      method: 'GET',\n      signal: options?.abortSignal,\n    },\n    options,\n  );\n\n  return {\n    url: response.url,\n    downloadUrl: response.downloadUrl,\n    pathname: response.pathname,\n    size: response.size,\n    contentType: response.contentType,\n    contentDisposition: response.contentDisposition,\n    cacheControl: response.cacheControl,\n    uploadedAt: new Date(response.uploadedAt),\n  };\n}\n", "import { requestApi } from './api';\nimport type { BlobCommandOptions } from './helpers';\n\nexport interface ListBlobResultBlob {\n  url: string;\n  downloadUrl: string;\n  pathname: string;\n  size: number;\n  uploadedAt: Date;\n}\n\nexport interface ListBlobResult {\n  blobs: ListBlobResultBlob[];\n  cursor?: string;\n  hasMore: boolean;\n}\n\nexport interface ListFoldedBlobResult extends ListBlobResult {\n  folders: string[];\n}\n\ninterface ListBlobApiResponseBlob\n  extends Omit<ListBlobResultBlob, 'uploadedAt'> {\n  uploadedAt: string;\n}\n\ninterface ListBlobApiResponse extends Omit<ListBlobResult, 'blobs'> {\n  blobs: ListBlobApiResponseBlob[];\n  folders?: string[];\n}\n\nexport interface ListCommandOptions<\n  M extends 'expanded' | 'folded' | undefined = undefined,\n> extends BlobCommandOptions {\n  /**\n   * The maximum number of blobs to return.\n   * @defaultvalue 1000\n   */\n  limit?: number;\n  /**\n   * Filters the result to only include blobs that start with this prefix.\n   * If used together with `mode: 'folded'`, make sure to include a trailing slash after the foldername.\n   */\n  prefix?: string;\n  /**\n   * The cursor to use for pagination. Can be obtained from the response of a previous `list` request.\n   */\n  cursor?: string;\n  /**\n   * Defines how the blobs are listed\n   * - `expanded` the blobs property contains all blobs.\n   * - `folded` the blobs property contains only the blobs at the root level of your store. Blobs that are located inside a folder get merged into a single entry in the folder response property.\n   * @defaultvalue 'expanded'\n   */\n  mode?: M;\n}\n\ntype ListCommandResult<\n  M extends 'expanded' | 'folded' | undefined = undefined,\n> = M extends 'folded' ? ListFoldedBlobResult : ListBlobResult;\n\n/**\n * Fetches a paginated list of blob objects from your store.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#list-blobs\n *\n * @param options - Additional options for the request.\n */\nexport async function list<\n  M extends 'expanded' | 'folded' | undefined = undefined,\n>(options?: ListCommandOptions<M>): Promise<ListCommandResult<M>> {\n  const searchParams = new URLSearchParams();\n\n  if (options?.limit) {\n    searchParams.set('limit', options.limit.toString());\n  }\n  if (options?.prefix) {\n    searchParams.set('prefix', options.prefix);\n  }\n  if (options?.cursor) {\n    searchParams.set('cursor', options.cursor);\n  }\n  if (options?.mode) {\n    searchParams.set('mode', options.mode);\n  }\n\n  const response = await requestApi<ListBlobApiResponse>(\n    `?${searchParams.toString()}`,\n    {\n      method: 'GET',\n      signal: options?.abortSignal,\n    },\n    options,\n  );\n\n  if (options?.mode === 'folded') {\n    return {\n      folders: response.folders ?? [],\n      cursor: response.cursor,\n      hasMore: response.hasMore,\n      blobs: response.blobs.map(mapBlobResult),\n    } as ListCommandResult<M>;\n  }\n\n  return {\n    cursor: response.cursor,\n    hasMore: response.hasMore,\n    blobs: response.blobs.map(mapBlobResult),\n  } as ListCommandResult<M>;\n}\n\nfunction mapBlobResult(\n  blobResult: ListBlobApiResponseBlob,\n): ListBlobResultBlob {\n  return {\n    url: blobResult.url,\n    downloadUrl: blobResult.downloadUrl,\n    pathname: blobResult.pathname,\n    size: blobResult.size,\n    uploadedAt: new Date(blobResult.uploadedAt),\n  };\n}\n", "import { requestApi } from './api';\nimport type { CommonCreateBlobOptions } from './helpers';\nimport { BlobError } from './helpers';\n\nexport type CopyCommandOptions = CommonCreateBlobOptions;\n\nexport interface CopyBlobResult {\n  url: string;\n  downloadUrl: string;\n  pathname: string;\n  contentType?: string;\n  contentDisposition: string;\n}\n\n/**\n * Copies a blob to another location in your store.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#copy-a-blob\n *\n * @param fromUrl - The blob URL to copy. You can only copy blobs that are in the store, that your 'BLOB_READ_WRITE_TOKEN' has access to.\n * @param toPathname - The pathname to copy the blob to. This includes the filename.\n * @param options - Additional options. The copy method will not preserve any metadata configuration (e.g.: 'cacheControlMaxAge') of the source blob. If you want to copy the metadata, you need to define it here again.\n */\nexport async function copy(\n  fromUrl: string,\n  toPathname: string,\n  options: CopyCommandOptions,\n): Promise<CopyBlobResult> {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n  if (!options) {\n    throw new BlobError('missing options, see usage');\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n  if (options.access !== 'public') {\n    throw new BlobError('access must be \"public\"');\n  }\n\n  const headers: Record<string, string> = {};\n\n  if (options.addRandomSuffix !== undefined) {\n    headers['x-add-random-suffix'] = options.addRandomSuffix ? '1' : '0';\n  }\n\n  if (options.contentType) {\n    headers['x-content-type'] = options.contentType;\n  }\n\n  if (options.cacheControlMaxAge !== undefined) {\n    headers['x-cache-control-max-age'] = options.cacheControlMaxAge.toString();\n  }\n\n  const response = await requestApi<CopyBlobResult>(\n    `/${toPathname}?fromUrl=${fromUrl}`,\n    {\n      method: 'PUT',\n      headers,\n      signal: options.abortSignal,\n    },\n    options,\n  );\n\n  return {\n    url: response.url,\n    downloadUrl: response.downloadUrl,\n    pathname: response.pathname,\n    contentType: response.contentType,\n    contentDisposition: response.contentDisposition,\n  };\n}\n", "import type { PutCommandOptions } from './put';\nimport { createPutMethod } from './put';\nimport { createCreateMultipartUploadMethod } from './multipart/create';\nimport type { UploadPartCommandOptions } from './multipart/upload';\nimport { createUploadPartMethod } from './multipart/upload';\nimport type { CompleteMultipartUploadCommandOptions } from './multipart/complete';\nimport { createCompleteMultipartUploadMethod } from './multipart/complete';\nimport type { CommonCreateBlobOptions } from './helpers';\nimport { createCreateMultipartUploaderMethod } from './multipart/create-uploader';\n\n// expose generic BlobError and download url util\nexport { BlobError, getDownloadUrl } from './helpers';\n\n// expose api BlobErrors\nexport {\n  BlobAccessError,\n  BlobNotFoundError,\n  BlobStoreNotFoundError,\n  BlobStoreSuspendedError,\n  BlobUnknownError,\n  BlobServiceNotAvailable,\n  BlobRequestAbortedError,\n  BlobServiceRateLimited,\n} from './api';\n\n// vercelBlob.put()\n\nexport type { PutBlobResult } from './put-helpers';\nexport type { PutCommandOptions };\n\n/**\n * Uploads a blob into your store from your server.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#upload-a-blob\n *\n * If you want to upload from the browser directly, check out the documentation for client uploads: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#client-uploads\n *\n * @param pathname - The pathname to upload the blob to. For file upload this includes the filename. Pathnames that end with a slash are treated as folder creations.\n * @param bodyOrOptions - Either the contents of your blob or the options object. For file uploads this has to be a supported fetch body type https://developer.mozilla.org/en-US/docs/Web/API/fetch#body. For folder creations this is the options object since no body is required.\n * @param options - Additional options like `token` or `contentType` for file uploads. For folder creations this argument can be ommited.\n */\nexport const put = createPutMethod<PutCommandOptions>({\n  allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n});\n\n//  vercelBlob.del()\n\nexport { del } from './del';\n\n// vercelBlob.head()\n\nexport type { HeadBlobResult } from './head';\nexport { head } from './head';\n\n// vercelBlob.list()\n\nexport type {\n  ListBlobResultBlob,\n  ListBlobResult,\n  ListCommandOptions,\n  ListFoldedBlobResult,\n} from './list';\nexport { list } from './list';\n\n// vercelBlob.copy()\n\nexport type { CopyBlobResult, CopyCommandOptions } from './copy';\nexport { copy } from './copy';\n\n// vercelBlob. createMultipartUpload()\n// vercelBlob. uploadPart()\n// vercelBlob. completeMultipartUpload()\n// vercelBlob. createMultipartUploaded()\n\nexport const createMultipartUpload =\n  createCreateMultipartUploadMethod<CommonCreateBlobOptions>({\n    allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n  });\n\nexport const createMultipartUploader =\n  createCreateMultipartUploaderMethod<CommonCreateBlobOptions>({\n    allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n  });\n\nexport type { UploadPartCommandOptions };\nexport const uploadPart = createUploadPartMethod<UploadPartCommandOptions>({\n  allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n});\n\nexport type { CompleteMultipartUploadCommandOptions };\nexport const completeMultipartUpload =\n  createCompleteMultipartUploadMethod<CompleteMultipartUploadCommandOptions>({\n    allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n  });\n\nexport type { Part, PartInput } from './multipart/helpers';\n"],
  "mappings": "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",
  "names": ["original", "require_retry", "retry", "bytes", "isBuffer", "_a", "_b", "retry", "error", "bytes", "isBuffer", "put", "isPlainObject", "_a", "createMultipartUpload", "uploadPart", "completeMultipartUpload"]
}
