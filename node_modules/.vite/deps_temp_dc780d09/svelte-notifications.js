import {
  writable
} from "./chunk-E6ZP6LG5.js";
import {
  fade
} from "./chunk-UYDFXFL5.js";
import "./chunk-M6MB33T7.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  add_render_callback,
  append_dev,
  append_styles,
  attr_dev,
  check_outros,
  component_subscribe,
  construct_svelte_component_dev,
  create_component,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  init,
  insert_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  onDestroy,
  outro_and_destroy_block,
  safe_not_equal,
  setContext,
  set_style,
  space,
  text,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-RVLVW3YK.js";
import "./chunk-E3EO7R6B.js";

// node_modules/svelte-notifications/src/context.js
var context = {
  subscribe: null,
  addNotification: null,
  removeNotification: null,
  clearNotifications: null
};
var getNotificationsContext = () => getContext(context);
var context_default = context;

// node_modules/svelte-notifications/src/components/Notification.svelte
function create_fragment(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*item*/
    ctx[0]
  );
  function switch_props(ctx2) {
    return {
      props: {
        notification: (
          /*notification*/
          ctx2[1]
        ),
        withoutStyles: (
          /*withoutStyles*/
          ctx2[2]
        ),
        onRemove: (
          /*removeNotificationHandler*/
          ctx2[3]
        )
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const switch_instance_changes = {};
      if (dirty & /*notification*/
      2)
        switch_instance_changes.notification = /*notification*/
        ctx2[1];
      if (dirty & /*withoutStyles*/
      4)
        switch_instance_changes.withoutStyles = /*withoutStyles*/
        ctx2[2];
      if (dirty & /*item*/
      1 && switch_value !== (switch_value = /*item*/
      ctx2[0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Notification", slots, []);
  let { item } = $$props;
  let { notification = {} } = $$props;
  let { withoutStyles = false } = $$props;
  const { removeNotification: removeNotification2 } = getNotificationsContext();
  const { id, removeAfter } = notification;
  const removeNotificationHandler = () => removeNotification2(id);
  let timeout = null;
  if (removeAfter) {
    timeout = setTimeout(removeNotificationHandler, removeAfter);
  }
  onDestroy(() => {
    if (removeAfter && timeout)
      clearTimeout(timeout);
  });
  $$self.$$.on_mount.push(function() {
    if (item === void 0 && !("item" in $$props || $$self.$$.bound[$$self.$$.props["item"]])) {
      console.warn("<Notification> was created without expected prop 'item'");
    }
  });
  const writable_props = ["item", "notification", "withoutStyles"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Notification> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
    if ("notification" in $$props2)
      $$invalidate(1, notification = $$props2.notification);
    if ("withoutStyles" in $$props2)
      $$invalidate(2, withoutStyles = $$props2.withoutStyles);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    getNotificationsContext,
    item,
    notification,
    withoutStyles,
    removeNotification: removeNotification2,
    id,
    removeAfter,
    removeNotificationHandler,
    timeout
  });
  $$self.$inject_state = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
    if ("notification" in $$props2)
      $$invalidate(1, notification = $$props2.notification);
    if ("withoutStyles" in $$props2)
      $$invalidate(2, withoutStyles = $$props2.withoutStyles);
    if ("timeout" in $$props2)
      timeout = $$props2.timeout;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [item, notification, withoutStyles, removeNotificationHandler];
}
var Notification = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      item: 0,
      notification: 1,
      withoutStyles: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Notification",
      options,
      id: create_fragment.name
    });
  }
  get item() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set item(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get notification() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notification(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withoutStyles() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withoutStyles(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Notification_default = Notification;

// node_modules/svelte-notifications/src/components/DefaultNotification.svelte
var file = "node_modules\\svelte-notifications\\src\\components\\DefaultNotification.svelte";
function add_css(target) {
  append_styles(target, "svelte-1x27qg3", ".default-notification-style.svelte-1x27qg3.svelte-1x27qg3{position:relative;display:flex;align-items:stretch;justify-content:space-between;margin:12px;background:#fff;color:#000;border-radius:6px;box-shadow:0 4px 10px rgba(0, 0, 0, 0.08);min-height:0;min-width:200px;overflow:hidden}.default-notification-style-content.svelte-1x27qg3.svelte-1x27qg3{width:210px;padding:12px 6px 12px 12px;box-sizing:border-box;word-wrap:break-word}.default-notification-style-button.svelte-1x27qg3.svelte-1x27qg3{display:block;width:40px;padding:0;margin:0;border:none;border-left:1px solid #eee;outline:none;background:none;cursor:pointer;font-size:20px;color:#000;box-sizing:border-box}.default-notification-style-button.svelte-1x27qg3.svelte-1x27qg3:hover{background:rgba(0, 0, 0, 0.01)}.default-notification-error.svelte-1x27qg3.svelte-1x27qg3{background:#f3555a;color:#fff}.default-notification-error.svelte-1x27qg3 .default-notification-style-button.svelte-1x27qg3{border-left:1px solid rgba(255, 255, 255, 0.4);color:#fff}.default-notification-warning.svelte-1x27qg3.svelte-1x27qg3{background:#ffb900;color:#000}.default-notification-warning.svelte-1x27qg3 .default-notification-style-button.svelte-1x27qg3{border-left:1px solid rgba(0, 0, 0, 0.2);color:#000}.default-notification-success.svelte-1x27qg3.svelte-1x27qg3{background:#22ce6c;color:#fff}.default-notification-success.svelte-1x27qg3 .default-notification-style-button.svelte-1x27qg3{border-left:1px solid rgba(255, 255, 255, 0.4);color:#fff}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGVmYXVsdE5vdGlmaWNhdGlvbi5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBQ0UseURBQTRCLENBQzFCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLE9BQU8sQ0FDcEIsZUFBZSxDQUFFLGFBQWEsQ0FDOUIsTUFBTSxDQUFFLElBQUksQ0FDWixVQUFVLENBQUUsSUFBSSxDQUNoQixLQUFLLENBQUUsSUFBSSxDQUNYLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLFVBQVUsQ0FBRSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUMxQyxVQUFVLENBQUUsQ0FBQyxDQUNiLFNBQVMsQ0FBRSxLQUFLLENBQ2hCLFFBQVEsQ0FBRSxNQUNaLENBRUEsaUVBQW9DLENBQ2xDLEtBQUssQ0FBRSxLQUFLLENBQ1osT0FBTyxDQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FDM0IsVUFBVSxDQUFFLFVBQVUsQ0FDdEIsU0FBUyxDQUFFLFVBQ2IsQ0FFQSxnRUFBbUMsQ0FDakMsT0FBTyxDQUFFLEtBQUssQ0FDZCxLQUFLLENBQUUsSUFBSSxDQUNYLE9BQU8sQ0FBRSxDQUFDLENBQ1YsTUFBTSxDQUFFLENBQUMsQ0FDVCxNQUFNLENBQUUsSUFBSSxDQUNaLFdBQVcsQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FDM0IsT0FBTyxDQUFFLElBQUksQ0FDYixVQUFVLENBQUUsSUFBSSxDQUNoQixNQUFNLENBQUUsT0FBTyxDQUNmLFNBQVMsQ0FBRSxJQUFJLENBQ2YsS0FBSyxDQUFFLElBQUksQ0FDWCxVQUFVLENBQUUsVUFDZCxDQUVBLGdFQUFrQyxNQUFPLENBQ3ZDLFVBQVUsQ0FBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FDaEMsQ0FFQSx5REFBNEIsQ0FDMUIsVUFBVSxDQUFFLE9BQU8sQ0FDbkIsS0FBSyxDQUFFLElBQ1QsQ0FFQSwwQ0FBMkIsQ0FBQyxpREFBbUMsQ0FDN0QsV0FBVyxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDL0MsS0FBSyxDQUFFLElBQ1QsQ0FFQSwyREFBOEIsQ0FDNUIsVUFBVSxDQUFFLE9BQU8sQ0FDbkIsS0FBSyxDQUFFLElBQ1QsQ0FFQSw0Q0FBNkIsQ0FBQyxpREFBbUMsQ0FDL0QsV0FBVyxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDekMsS0FBSyxDQUFFLElBQ1QsQ0FFQSwyREFBOEIsQ0FDNUIsVUFBVSxDQUFFLE9BQU8sQ0FDbkIsS0FBSyxDQUFFLElBQ1QsQ0FFQSw0Q0FBNkIsQ0FBQyxpREFBbUMsQ0FDL0QsV0FBVyxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDL0MsS0FBSyxDQUFFLElBQ1QiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiRGVmYXVsdE5vdGlmaWNhdGlvbi5zdmVsdGUiXX0= */");
}
function create_if_block(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let t0;
  let button;
  let t1;
  let button_class_value;
  let div1_class_value;
  let div1_intro;
  let div1_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t0 = space();
      button = element("button");
      t1 = text("×");
      attr_dev(div0, "class", div0_class_value = null_to_empty(
        /*getClass*/
        ctx[2]("content")
      ) + " svelte-1x27qg3");
      add_location(div0, file, 102, 4, 2261);
      attr_dev(button, "class", button_class_value = null_to_empty(
        /*getClass*/
        ctx[2]("button")
      ) + " svelte-1x27qg3");
      attr_dev(button, "aria-label", "delete notification");
      add_location(button, file, 105, 4, 2336);
      attr_dev(div1, "class", div1_class_value = null_to_empty(
        /*getClass*/
        ctx[2]()
      ) + " svelte-1x27qg3");
      attr_dev(div1, "role", "status");
      attr_dev(div1, "aria-live", "polite");
      add_location(div1, file, 95, 2, 2159);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div0, null);
      }
      append_dev(div1, t0);
      append_dev(div1, button);
      append_dev(button, t1);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*onRemove*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (div1_outro)
          div1_outro.end(1);
        div1_intro = create_in_transition(div1, fade, {});
        div1_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      if (div1_intro)
        div1_intro.invalidate();
      div1_outro = create_out_transition(div1, fade, {});
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (detaching && div1_outro)
        div1_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(95:0) {#if text}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*text*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(104:12) {text}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*text*/
    ctx[1] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*text*/
        ctx2[1]
      )
        if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DefaultNotification", slots, ["default"]);
  let { notification = {} } = $$props;
  let { withoutStyles = false } = $$props;
  let { onRemove = null } = $$props;
  const { text: text2, type } = notification;
  const getClass = (suffix) => {
    const defaultSuffix = suffix ? `-${suffix}` : "";
    const defaultNotificationClass = ` default-notification-style${defaultSuffix}`;
    const defaultNotificationType = type && !suffix ? ` default-notification-${type}` : "";
    return `notification${defaultSuffix}${withoutStyles ? "" : defaultNotificationClass}${defaultNotificationType}`;
  };
  const writable_props = ["notification", "withoutStyles", "onRemove"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DefaultNotification> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("notification" in $$props2)
      $$invalidate(3, notification = $$props2.notification);
    if ("withoutStyles" in $$props2)
      $$invalidate(4, withoutStyles = $$props2.withoutStyles);
    if ("onRemove" in $$props2)
      $$invalidate(0, onRemove = $$props2.onRemove);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    fade,
    notification,
    withoutStyles,
    onRemove,
    text: text2,
    type,
    getClass
  });
  $$self.$inject_state = ($$props2) => {
    if ("notification" in $$props2)
      $$invalidate(3, notification = $$props2.notification);
    if ("withoutStyles" in $$props2)
      $$invalidate(4, withoutStyles = $$props2.withoutStyles);
    if ("onRemove" in $$props2)
      $$invalidate(0, onRemove = $$props2.onRemove);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [onRemove, text2, getClass, notification, withoutStyles, $$scope, slots];
}
var DefaultNotification = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        notification: 3,
        withoutStyles: 4,
        onRemove: 0
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DefaultNotification",
      options,
      id: create_fragment2.name
    });
  }
  get notification() {
    throw new Error("<DefaultNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notification(value) {
    throw new Error("<DefaultNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withoutStyles() {
    throw new Error("<DefaultNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withoutStyles(value) {
    throw new Error("<DefaultNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onRemove() {
    throw new Error("<DefaultNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onRemove(value) {
    throw new Error("<DefaultNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DefaultNotification_default = DefaultNotification;

// node_modules/svelte-notifications/src/positions.js
var positions = [
  "top-left",
  "top-center",
  "top-right",
  "bottom-left",
  "bottom-center",
  "bottom-right"
];
var positions_default = positions;

// node_modules/svelte-notifications/src/store/actions/addNotification.js
var addNotification = (notification, store) => {
  if (!notification)
    return;
  const { update } = store;
  const safeNotification = {
    id: `${(/* @__PURE__ */ new Date()).getTime()}-${Math.floor(Math.random() * 9999)}`,
    position: "bottom-center",
    text: "",
    ...notification
  };
  if (!positions_default.includes(notification.position))
    return;
  update((notifications) => {
    if (safeNotification.position.includes("top-")) {
      return [safeNotification, ...notifications];
    }
    return [...notifications, safeNotification];
  });
};
var addNotification_default = addNotification;

// node_modules/svelte-notifications/src/store/actions/removeNotification.js
var removeNotification = (notificationId, { update }) => {
  if (!notificationId)
    return;
  update((notifications) => notifications.filter(({ id }) => id !== notificationId));
};
var removeNotification_default = removeNotification;

// node_modules/svelte-notifications/src/store/actions/clearNotifications.js
var clearNotifications = (store) => store.set([]);
var clearNotifications_default = clearNotifications;

// node_modules/svelte-notifications/src/store/index.js
var createStore = () => {
  const store = writable([]);
  return {
    subscribe: store.subscribe,
    addNotification: (notification) => addNotification_default(notification, store),
    removeNotification: (notificationId) => removeNotification_default(notificationId, store),
    clearNotifications: () => clearNotifications_default(store)
  };
};
var store_default = createStore();

// node_modules/svelte-notifications/src/components/Notifications.svelte
var file2 = "node_modules\\svelte-notifications\\src\\components\\Notifications.svelte";
function add_css2(target) {
  append_styles(target, "svelte-t0tmtn", ".default-position-style-top-left.svelte-t0tmtn,.default-position-style-top-center.svelte-t0tmtn,.default-position-style-top-right.svelte-t0tmtn,.default-position-style-bottom-left.svelte-t0tmtn,.default-position-style-bottom-center.svelte-t0tmtn,.default-position-style-bottom-right.svelte-t0tmtn{position:fixed;max-width:400px}.default-position-style-top-left.svelte-t0tmtn{top:0;left:0}.default-position-style-top-center.svelte-t0tmtn{top:0;left:50%;transform:translateX(-50%)}.default-position-style-top-right.svelte-t0tmtn{top:0;right:0}.default-position-style-bottom-left.svelte-t0tmtn{bottom:0;left:0}.default-position-style-bottom-center.svelte-t0tmtn{bottom:0;left:50%;transform:translateX(-50%)}.default-position-style-bottom-right.svelte-t0tmtn{bottom:0;right:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTm90aWZpY2F0aW9ucy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBQ0UsOENBQWdDLENBQ2hDLGdEQUFrQyxDQUNsQywrQ0FBaUMsQ0FDakMsaURBQW1DLENBQ25DLG1EQUFxQyxDQUNyQyxrREFBcUMsQ0FDbkMsUUFBUSxDQUFFLEtBQUssQ0FDZixTQUFTLENBQUUsS0FDYixDQUVBLDhDQUFpQyxDQUMvQixHQUFHLENBQUUsQ0FBQyxDQUNOLElBQUksQ0FBRSxDQUNSLENBRUEsZ0RBQW1DLENBQ2pDLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLEdBQUcsQ0FDVCxTQUFTLENBQUUsV0FBVyxJQUFJLENBQzVCLENBRUEsK0NBQWtDLENBQ2hDLEdBQUcsQ0FBRSxDQUFDLENBQ04sS0FBSyxDQUFFLENBQ1QsQ0FFQSxpREFBb0MsQ0FDbEMsTUFBTSxDQUFFLENBQUMsQ0FDVCxJQUFJLENBQUUsQ0FDUixDQUVBLG1EQUFzQyxDQUNwQyxNQUFNLENBQUUsQ0FBQyxDQUNULElBQUksQ0FBRSxHQUFHLENBQ1QsU0FBUyxDQUFFLFdBQVcsSUFBSSxDQUM1QixDQUVBLGtEQUFxQyxDQUNuQyxNQUFNLENBQUUsQ0FBQyxDQUNULEtBQUssQ0FBRSxDQUNUIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIk5vdGlmaWNhdGlvbnMuc3ZlbHRlIl19 */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function create_if_block2(ctx) {
  let notification;
  let current;
  notification = new Notification_default({
    props: {
      notification: (
        /*notification*/
        ctx[10]
      ),
      withoutStyles: (
        /*withoutStyles*/
        ctx[1]
      ),
      item: (
        /*item*/
        ctx[0] || DefaultNotification_default
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(notification.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(notification, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const notification_changes = {};
      if (dirty & /*$store*/
      8)
        notification_changes.notification = /*notification*/
        ctx2[10];
      if (dirty & /*withoutStyles*/
      2)
        notification_changes.withoutStyles = /*withoutStyles*/
        ctx2[1];
      if (dirty & /*item*/
      1)
        notification_changes.item = /*item*/
        ctx2[0] || DefaultNotification_default;
      notification.$set(notification_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(notification.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(notification.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(notification, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(75:8) {#if notification.position === position}",
    ctx
  });
  return block;
}
function create_each_block_1(key_1, ctx) {
  let first;
  let if_block_anchor;
  let current;
  let if_block = (
    /*notification*/
    ctx[10].position === /*position*/
    ctx[7] && create_if_block2(ctx)
  );
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*notification*/
        ctx[10].position === /*position*/
        ctx[7]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*$store*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(74:6) {#each $store as notification (notification.id)}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let div_class_value;
  let current;
  let each_value_1 = (
    /*$store*/
    ctx[3]
  );
  validate_each_argument(each_value_1);
  const get_key = (ctx2) => (
    /*notification*/
    ctx2[10].id
  );
  validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      attr_dev(div, "class", div_class_value = null_to_empty(
        /*getClass*/
        ctx[4](
          /*position*/
          ctx[7]
        )
      ) + " svelte-t0tmtn");
      set_style(
        div,
        "z-index",
        /*zIndex*/
        ctx[2]
      );
      add_location(div, file2, 69, 4, 1479);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append_dev(div, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$store, withoutStyles, item, DefaultNotification, positions*/
      11) {
        each_value_1 = /*$store*/
        ctx2[3];
        validate_each_argument(each_value_1);
        group_outros();
        validate_each_keys(ctx2, each_value_1, get_each_context_1, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, div, outro_and_destroy_block, create_each_block_1, t, get_each_context_1);
        check_outros();
      }
      if (dirty & /*zIndex*/
      4) {
        set_style(
          div,
          "z-index",
          /*zIndex*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(69:2) {#each positions as position}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let t;
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let each_value = positions_default;
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
      t = space();
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "notifications");
      add_location(div, file2, 67, 0, 1415);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_dev(target, t, anchor);
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (dirty & /*getClass, positions, zIndex, $store, withoutStyles, item, DefaultNotification*/
      31) {
        each_value = positions_default;
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $store;
  validate_store(store_default, "store");
  component_subscribe($$self, store_default, ($$value) => $$invalidate(3, $store = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Notifications", slots, ["default"]);
  let { item = null } = $$props;
  let { withoutStyles = false } = $$props;
  let { zIndex = null } = $$props;
  const getClass = (position = "") => {
    const defaultPositionClass = ` default-position-style-${position}`;
    return `position-${position}${withoutStyles ? "" : defaultPositionClass}`;
  };
  setContext(context_default, store_default);
  const writable_props = ["item", "withoutStyles", "zIndex"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Notifications> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
    if ("withoutStyles" in $$props2)
      $$invalidate(1, withoutStyles = $$props2.withoutStyles);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    Notification: Notification_default,
    DefaultNotification: DefaultNotification_default,
    context: context_default,
    store: store_default,
    positions: positions_default,
    item,
    withoutStyles,
    zIndex,
    getClass,
    $store
  });
  $$self.$inject_state = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
    if ("withoutStyles" in $$props2)
      $$invalidate(1, withoutStyles = $$props2.withoutStyles);
    if ("zIndex" in $$props2)
      $$invalidate(2, zIndex = $$props2.zIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [item, withoutStyles, zIndex, $store, getClass, $$scope, slots];
}
var Notifications = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { item: 0, withoutStyles: 1, zIndex: 2 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Notifications",
      options,
      id: create_fragment3.name
    });
  }
  get item() {
    throw new Error("<Notifications>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set item(value) {
    throw new Error("<Notifications>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withoutStyles() {
    throw new Error("<Notifications>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withoutStyles(value) {
    throw new Error("<Notifications>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Notifications>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Notifications>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Notifications_default = Notifications;

// node_modules/svelte-notifications/src/index.js
var src_default = Notifications_default;
export {
  src_default as default,
  getNotificationsContext
};
//# sourceMappingURL=svelte-notifications.js.map
